(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{353:function(t,e,v){"use strict";v.r(e);var a=v(42),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"介绍下bfc-ifc-ffc-gfc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍下bfc-ifc-ffc-gfc"}},[t._v("#")]),t._v(" 介绍下BFC，IFC，FFC，GFC")]),t._v(" "),v("p",[t._v("这是css的四种不同的渲染模式，一般可以通过"),v("code",[t._v("display: block/inline-block/flex/grid")]),t._v(" 设置。")]),t._v(" "),v("h2",{attrs:{id:"bfc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bfc"}},[t._v("#")]),t._v(" BFC")]),t._v(" "),v("p",[t._v("块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。")]),t._v(" "),v("p",[t._v("下面方式会创建BFC：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("float")]),t._v(" 的值不是 "),v("code",[t._v("none")])]),t._v(" "),v("li",[v("code",[t._v("position")]),t._v(" 的值是"),v("code",[t._v("absolute")]),t._v("、"),v("code",[t._v("fixed")])]),t._v(" "),v("li",[v("code",[t._v("display")]),t._v(" 的值是 "),v("code",[t._v("inline-block")]),t._v("、"),v("code",[t._v("flow-root")]),t._v("、"),v("code",[t._v("table-cell")]),t._v("、"),v("code",[t._v("table-caption")]),t._v("、"),v("code",[t._v("flex")]),t._v("或者 "),v("code",[t._v("inline-flex")]),t._v("、"),v("code",[t._v("grid")]),t._v("或者"),v("code",[t._v("inline-grid")])]),t._v(" "),v("li",[v("code",[t._v("overflow")]),t._v(" 的值不是 "),v("code",[t._v("visible")])])]),t._v(" "),v("h3",{attrs:{id:"作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),v("h4",{attrs:{id:"清除浮动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#清除浮动"}},[t._v("#")]),t._v(" 清除浮动")]),t._v(" "),v("p",[t._v("子元素浮动，脱离了普通文档流，子元素不会默认撑开父元素，通过设置父元素创建BFC可以解决这个问题。")]),t._v(" "),v("h4",{attrs:{id:"解决上下margin边距问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决上下margin边距问题"}},[t._v("#")]),t._v(" 解决上下margin边距问题")]),t._v(" "),v("p",[t._v("同一层级两个元素上下边距会重叠，通过设置第二个元素创建BFC可以解决。")]),t._v(" "),v("h4",{attrs:{id:"实现自适应两栏布局"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现自适应两栏布局"}},[t._v("#")]),t._v(" 实现自适应两栏布局")]),t._v(" "),v("p",[t._v("通过浮动设置两栏布局时，浮动的内容会覆盖元素，通过设置第二个元素BFC可以解决。")]),t._v(" "),v("h2",{attrs:{id:"ifc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ifc"}},[t._v("#")]),t._v(" IFC")]),t._v(" "),v("p",[t._v("IFC的全称是Inline Formatting Contexts，也就是“内联格式化上下文”。\n子元素只会计算横向样式空间，"),v("code",[t._v("【padding、border、margin】")]),t._v("，垂直方向样式空间不会被计算，"),v("code",[t._v("【padding、border、margin】")]),t._v("。")]),t._v(" "),v("p",[t._v("用于行内需求。作用：")]),t._v(" "),v("ul",[v("li",[t._v("水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。")]),t._v(" "),v("li",[t._v("垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。")])]),t._v(" "),v("h4",{attrs:{id:"ffc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ffc"}},[t._v("#")]),t._v(" FFC")]),t._v(" "),v("p",[t._v("FFC的全称是Flex formatting contexts，弹性盒模型。\n通过设置 "),v("code",[t._v("display: flex;")]),t._v("或 "),v("code",[t._v("display: inline-flex;")]),t._v(" 实现，要注意一点。生成FFC后，其子元素的"),v("code",[t._v("float")]),t._v("、"),v("code",[t._v("clear")]),t._v("和 "),v("code",[t._v("vertical-align")]),t._v(" 属性将失效。")]),t._v(" "),v("h4",{attrs:{id:"gfc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gfc"}},[t._v("#")]),t._v(" GFC")]),t._v(" "),v("p",[t._v("当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。")])])}),[],!1,null,null,null);e.default=_.exports}}]);